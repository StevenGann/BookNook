# Village – RP2350-Zero bitmap-only animations.
# Scenes 0–254: bitmap data from bitmap_anim.bin (generated by tools/image_sequence_to_bitmap.py).
# All scenes play at 24 fps and loop until another scene is triggered over I2C.

import struct

try:
    from display_driver import pixel as set_pixel
except ImportError:
    def set_pixel(disp, x, y, c):
        if disp and hasattr(disp, "pixel"):
            disp.pixel(x, y, c)
        elif disp and hasattr(disp, "fill_rect"):
            disp.fill_rect(x, y, 1, 1, c)

# Header: BANM (4) + width (2) + height (2) + frame_count[255] (510) = 518 bytes
HEADER_SIZE = 4 + 2 + 2 + 255 * 2
BITMAP_FILENAME = "bitmap_anim.bin"
NUM_SCENES = 255

# Cached header: (width, height, frame_counts list of 255)
_bitmap_cache = None


def _read_bitmap_header(f):
    """Read header (518 bytes for 255 scenes). Returns (width, height, frame_counts) or None."""
    buf = f.read(HEADER_SIZE)
    if len(buf) < HEADER_SIZE or buf[:4] != b"BANM":
        return None
    width, height = struct.unpack("<HH", buf[4:8])
    frame_counts = list(struct.unpack("<" + "H" * NUM_SCENES, buf[8:HEADER_SIZE]))
    return (width, height, frame_counts)


def _scene_byte_offset(frame_size, frame_counts, scene_id, frame_index):
    """Byte offset in file for scene scene_id, frame frame_index (after the header)."""
    offset = 0
    for s in range(scene_id):
        offset += frame_counts[s] * frame_size
    offset += frame_index * frame_size
    return offset


def draw_bitmap(display, scene_id, time_ticks_ms, scene_start_ticks):
    """
    Draw current frame for scene_id from bitmap_anim.bin.
    Frame index = (elapsed_ms * 24 / 1000) % num_frames for 24 fps loop.
    """
    global _bitmap_cache
    if not display:
        return
    if scene_id < 0 or scene_id >= NUM_SCENES:
        scene_id = 0
    try:
        f = open(BITMAP_FILENAME, "rb")
    except OSError:
        _bitmap_cache = None
        display.fill(0)
        return
    try:
        if _bitmap_cache is None:
            _bitmap_cache = _read_bitmap_header(f)
        if _bitmap_cache is None:
            display.fill(0)
            return
        width, height, frame_counts = _bitmap_cache
        if frame_counts[scene_id] == 0:
            scene_id = 0
        num_frames = frame_counts[scene_id]
        if num_frames == 0:
            display.fill(0)
            return
        elapsed_ms = time_ticks_ms - scene_start_ticks
        if elapsed_ms < 0:
            elapsed_ms = 0
        frame_index = (elapsed_ms * 24 // 1000) % num_frames
        frame_size = width * height * 2
        offset = HEADER_SIZE + _scene_byte_offset(frame_size, frame_counts, scene_id, frame_index)
        f.seek(offset)
        buf = f.read(frame_size)
        if len(buf) < frame_size:
            display.fill(0)
            return
        if hasattr(display, "blit_buffer"):
            display.blit_buffer(buf, 0, 0, width, height)
        else:
            for y in range(height):
                for x in range(width):
                    i = (y * width + x) * 2
                    c = buf[i] | (buf[i + 1] << 8)
                    set_pixel(display, x, y, c)
    except Exception:
        display.fill(0)
    finally:
        try:
            f.close()
        except Exception:
            pass


def run_frame(display, scene_id, time_ticks_ms, scene_start_ticks):
    """
    Draw one frame. Scenes 0–7 are bitmap; anything else shows black.
    time_ticks_ms and scene_start_ticks are used for 24 fps playback (scene_start_ticks when scene was selected).
    """
    if scene_id < 0 or scene_id >= NUM_SCENES:
        if display:
            display.fill(0)
        return
    draw_bitmap(display, scene_id, time_ticks_ms, scene_start_ticks)
